# 추상화 기법

> 자바스크립트처럼 클래스가 존재하지 않는 프로토타입 기반의 언어는 아리스토텔레스의 객관적인 분류 체계가 존재한다는 
> 사상에 대한 철학적 의문에 그 뿌리를 두고 있다.
> 클래스가 없는 프로토타입 언어에서 분류와 인스턴스화는 프로토타입이라는 객체의 복사를 통해 이뤄진다.

## 분류와 인스턴스화 

### 개념과 범주

**개념**

속성과 행위가 유사한 객체에 공통적으로 적용되는 관념이나 아이디어다.

**변주**

객체들을 공통적인 특성을 기반으로 범주로 묶고 개념을 적용하는 것

**분류**

세상에 존재하는 객체에 개념을 적용하는 과정 

분류는 객체를 특정한 개념을 나타내는 집합의 구성 요소로 포함시킨다.

<br>

세상에 존재하는 서로 다른 상태를 가진 무수히 많은 자동차와 나무를 자동차나 나무라는 범주로 묶음으로써 세상에 존재하는 복잡성을 낮출 수 있다.

분류를 통해 개별 현상을 하나의 개념으로 다룬다.

'수많은 개별적인 현상들'을 **객체** 라고 하고,

'하나의 개념'을 **타입**이라고 한다.

분류는 객체를 타입과 연관시키는 것이다. 

분류의 역은 타입에 해당하는 객체를 생성하는 과정으로 **인스턴스화** 또는 **예시**라고 한다.

<br>

### 타입

타입을 객체의 분류 장치로서 적용할 수 있으려면 3가지 관점에서의 정의가 필요하다.

* **내연**: 어떤 객체가 의미적으로 자동차라는 타입에 속하는지 여부를 판단할 수 있는 정의
* **심볼**: 커뮤니케이션
* **외연**: 내연이 맞다면 외연에 포함될 수 있다.

<br>

### 외연과 집합 

타입의 외연은 타입에 속하는 객체들의 집합으로 표현한다.

집합은 외연을 가리키는 또 다른 명칭이다.

**단일 분류**

한 객체가 한 시점에 하나의 타입에만 속하는 것

대부분의 객체지향 프로그래밍 언어들은 단일 분류만을 지원한다.

**다중 분류**

한 객체가 한 시점에 여러 타입에 속할 경우 

다중 분류를 다중 상속과 혼동해서는 안된다.

**다중 상속**은 하나의 타입이 다수의 슈퍼타입을 가질 수 있도록 허용하지만 타입 정의를 생략할 수는 없다.

반면 다중 분류는 특정한 타입을 정의하지 않고도 하나의 객체가 서로 다른 타입의 인스턴스가 되도록 하용한다.

**동적 분류**

객체가 한 집합에서 다른 집합의 원소로 자신이 속하는 타입을 변경할 수 있는 경우

**정적 분류**

객체가 자신의 타입을 변경할 수 없는 경우

대부분의 언어는 정적 분류만 허용하며 동적 분류를 구현할 수 있는 방법을 제공하지 않는다.

<br>

## 클래스

아리스토텔레스는 객체의 특성을 본질적인 속성과 우연적인 속성으로 분류했다. 본질이란 한 사물의 가장 핵심적이고 필수불가결한 속성이다. 본질적이지 않은 속성을 우연적 속성이라고 한다.

대부분의 객체지향 언어는 본질적인 속성은 표현할 수 있지만 우연적인 속성은 표현할 수 없다.

따라서 동일한 범주에 속하는 객체는 모두 동일한 속성을 가져야만 한다.

<br>

### 서브 타입

**슈퍼타입(supertype)**

어떤 타입이 다른 타입보다 일반 적이라면 슈퍼타입

**서브타입(subtype)**

어떤 타입이 다른 타입보다 좀 더 특수하다면 이 타입은 서브타입

<br>

슈퍼타입은 서브타입의 일반화이고 서브타입은 슈퍼타입의 특수화다.

일반화와 특수화의 계층 구조에서 서브타입은 슈퍼타입이 가진 본질적인 속성과 함께 자신만의 추가적인 속성을 가진다.

내연의 관점에서 슈퍼타입의 정의가 서브타입의 정의보다 더 일반적인 것을 의미한다. 

<br>

> 아리스토텔레스를 중심으로 한 그리스 철할은 1) 사물의 속성 자체에 주의를 기울이고
> 2) 그 속성에 근거해서 사물을 범주화하며 3) 그 범주들을 사용해 어떤 규칙을 만들어, 4) 사물들의 움직임을 그 규칙으로 설명하고자 한다.

이런식으로 귀납적 추리를 가능하게 한다.

일반화의 특징을 이용하면 부분적인 사실을 통해 복잡한 사실에 대한 논리적인 추론이 가능해진다.

* **100% 규칙**: 수퍼타입의 정의가 100% 서브타입에 적용돼야만 한다. 서브타입은 속성과 연관관계 면에서 슈퍼타입과 100% 일치해야 한다.
* **is-a 규칙**: 서브타입의 모든 인스턴스는 슈퍼타입 집합에 포함돼야 한다. 이는 대개 영어로 서브타입은 슈퍼타입이다.(subtype is a supertype)라는 문구을 만듦으로써 테스트할 수 있다.

<br>

### 상속

**구조적인 순응**

타입의 내연과 관련된 100% 규칙을 의미한다. 서브타입은 슈퍼타입이 가지고 있는 속성과 연관관계 면에서 100% 일치해야 한다.

**행위적인 순응**

타입의 행위에 관한 것이며, 서브타입은 슈퍼타입을 행위적으로 대체 가능해야 한다. 

**서브타이핑**

서브클래스가 슈퍼클래스를 대체할 수 있는 경우

구현 상속

**서브클래싱**

서브클래스가 슈퍼클래스를 대체할 수 없는 경우

인터페이스 상속

**위임**

어떤 객체의 클래스가 수신된 메시지를 이해할 수 없다면 메시지를 클래스의 부모 클래스로 위임한다. 만약 부모 클래스에서도 메시지를 이해할 수 없다면 자신의 부모 클래스로 다시 메시지를 위임한다. 

클래스간의 위임 사슬은 계층 내의 어떤 클래스가 메시지를 처리하거나 최상위 부모 클래스에 위임될 때까지 계속된다. 

**상속**

어떤 타입의 객체를 특정 객체 타입의 특수화로 만들거나 행동을 공유할 수 있게 만들고 싶은 경우 객체와 캑체를 상속 관계를 통해 연결한다. 

<br>

## 집합과 분해

### 계층적인 복잡성

**집합**

안정적인 형태의 부분으로부터 전체를 구축하는 행위

**분해**

집합과 반대로 전체를 부분으로 분할하는 행위 

집합은 불필요한 세부 사항을 배제하고 큰 그림에서 대상을 다룰 수 있게 한다.

필요한 시점에는 전체를 분해함으로써 그 안에 포함된 부분들을 새로운 전체로 다룰 수 있다.

전체와 부분 간의 일관된 계층 구조는 재귀적인 설계를 가능하게 한다. 

<br>

### 합성관계

부분을 전체 안에 캡슐화함으로써 인지 과부하를 방지한다.

합성 관계로 연결된 객체는 포함하는 객체가 제거될 때 내부에 포함된 객체도 함께 제거된다.

**연관관계** 

연결된 두 객체는 생명주기와 관련된 어떤 제약도 부과하지 않는다. 연관 관계로 연결된 두 객체는 독립적으로 제거될 수 있다.

### 패키지

상공에서 바라본 소프트웨어의 전체적인 구조를 표현하기 위해 관련된 클래스 집합을 하나의 논리적인 단위로 묶는 구성 요소를 **패키지** 또는 **모듈** 이라고 한다. 

개별 클래스가 아닌 클래스의 집합을 캡슐화함으로써 전체적인 복잡도를 낮출 수 있다. 
